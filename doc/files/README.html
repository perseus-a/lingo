<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Aug 01 19:43:10 +0200 2007</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>Lingo - Linguistisches Lego</h1>
<p>
Lingo ist ein freies Indexierungssystem für Forschung und Lehre. Die
wesentlichen Funktionen von Lingo sind
</p>
<ul>
<li>Grundformidentifizierung bzw. -reduzierung mitttels einfacher Suffixliste

</li>
<li>algorythmische Kompositumzerlegung

</li>
<li>lexikalische wörterbuchbasierte Relationierung und Mehrworterkennung

</li>
<li>generische Mehrwort bzw. Sequenzerkennung auf Basis von Wortklassenfolgen

</li>
</ul>
<h1>Credits</h1>
<p>
Lingo ist eine gemeinschaftliche Entwicklung von Klaus Lepsky und John
Vorhauer.
</p>
<h2>Einführung</h2>
<p>
Lingo ist linguistisches Lego. Sollen Texte einer linguistischen Analyse
unterzogen werden, so kann man mit Lingo alles bewerkstelligen, was das
Herz begehrt. Lingo ist eine Systematik die es erlaubt, einzelne Bausteine
mit begrenzter Funktion zu einen Netzwerk mit unbegrenzter Funktion
zusammen zu bauen. Gebaut werden diese Netzwerk für Lingo in
Konfigurationsdateien. Ein kleines Beispiel:
</p>
<pre>
        &lt;lingo&gt;
                &lt;attendee name='textreader' out='lines' files='README.txt'/&gt;
                &lt;attendee name='debugger' in='lines'/&gt;
        &lt;/lingo&gt;
</pre>
<p>
Lingo wird angewiesen, zwei Attendees (Teilnehmer) einzuladen. Und Lingo
möchte, dass sie miteinander sprechen. Daher kommt ja auch der Name Lingo
(=die Fachsprache).
</p>
<p>
Der erste Teilnehmer ist der <b><a
href="../classes/Textreader.html">Textreader</a></b>. Er kann Dateien lesen
und anderen Teilnehmern den Inhalt mitteilen. Dazu wird dem <b><a
href="../classes/Textreader.html">Textreader</a></b> der Ausgabekanal
<b>lines</b> (out=&#8216;lines&#8217;) erzeugt. Alles, was der <a
href="../classes/Textreader.html">Textreader</a> zu sagen hat, wird über
diesen Kanal geschleust. Das war&#8216;s fast für den <b><a
href="../classes/Textreader.html">Textreader</a></b>. Der tut jetzt erst
einmal nichts, bis Lingo den ersten Teilnehmer aufordern wird, zu reden.
Dann öffnet der <b><a href="../classes/Textreader.html">Textreader</a></b>
die Datei README.txt (files-Parameter) und plappert den Inhalt über den
<b>lines</b>-Kanal in die Welt hinaus. Der zweite Teilnehmer
<b>debugger</b> macht nichts anderes, als alles, was über seinen
Eingabekanal herein kommt (in=&#8216;lines&#8217;), auf der Konsole
auszugeben. Schreibt man die obige Lingo-Konfiguration in die Datei
README.XML und ruft anschließend <tt>ruby lingo.rb -c readme</tt> auf, so
schaut das Ergebnis dieser ersten Lingo-Konfiguration in etwa so aus:
</p>
<pre>
        &lt;debug&gt;:  CMD: FILE (README.txt)
        &lt;debug&gt;:  &quot;= Lingo&quot;
        &lt;debug&gt;:  &quot;== Einf\374hrung&quot;
        &lt;debug&gt;:  &quot;Lingo ist linguistisches Lego. Sollen Texte einer linguistischen Analyse unterzogen werden, &quot;
        &lt;debug&gt;:  &quot;so kann man mit Lingo alles bewerkstelligen, was das Herz begehrt.&quot;
                 ....
        &lt;debug&gt;:  CMD: EOF (README.txt)

        ----------------------------------------
        Die Dauer der Sitzung war  0.00 sec.
</pre>
<p>
Was wir sehen, sind Zeilen mit CMD: und Zeilen ohne. Und das ist auch gut
so! Lingo unterscheidet nämlich zwischen Kommando und Daten. Der <b><a
href="../classes/Textreader.html">Textreader</a></b> hat nicht nur den
Inhalt der Datei gelesen, sondern auch zusätzlich über die Kommandos
mitgeteilt, wann welche Datei anfängt und wann sie zuende ist. Dies kann
(und wird) eine wichtige Information für andere Teilnehmer werden, die
später hinzukommen.
</p>
<p>
So, damit ist zu Lingo eigentlich alles gesagt :o)
</p>
<p>
Vielleicht noch eine kleine Übersicht über mögliche Teilnehmer, die man zur
Lösung seines speziellen Problems heranziehen kann (für weitere
Informationen sei auf die jeweilige Dokumentation des Teilnehmers
verwiesen):
</p>
<table>
<tr><td valign="top"><b><a href="../classes/Textreader.html">Textreader</a></b>:</td><td>Liest Dateien und gibt deren Inhalt zeilenweise in die Kanäle.

</td></tr>
<tr><td valign="top"><b><a href="../classes/Tokenizer.html">Tokenizer</a></b>:</td><td>Zerlegt Zeilen in definierte Zeichenketten der Klasse Token.

</td></tr>
<tr><td valign="top"><b>Stopworder</b>:</td><td>Markiert Token, die in der Stopwort-Liste enthalten sind, als Stopwort.

</td></tr>
<tr><td valign="top"><b><a href="../classes/Wordsearcher.html">Wordsearcher</a></b>:</td><td>Macht aus Token Objekte der Klasse Word. Ums richtig zu machen schaut er
dabei noch in Wörterbücher, versucht Flexionen zu berücksichtigen und wenn
alles nichts hilft, testet er auch noch auf Komposita.

</td></tr>
<tr><td valign="top"><b><a href="../classes/Synonymer.html">Synonymer</a></b>:</td><td>Erweitert Objekte der Klasse Word um Synonyme, die zu deren Grundform
gefunden werden.

</td></tr>
<tr><td valign="top"><b><a href="../classes/Noneword_filter.html">Noneword_filter</a></b>:</td><td>Filtert alles raus und gibt nur unbekannte Wörter weiter.

</td></tr>
<tr><td valign="top"><b><a href="../classes/Vector_filter.html">Vector_filter</a></b>:</td><td>Filtert alles raus und gibt nur die Zeichenketten weiter, die für die
Indexierung als Vektor zu gebrauchen sind.

</td></tr>
<tr><td valign="top"><b><a href="../classes/Textwriter.html">Textwriter</a></b>:</td><td>Gibt alles, was er bekommt, in eine Datei aus.

</td></tr>
<tr><td valign="top"><b><a href="../classes/Debugger.html">Debugger</a></b>:</td><td>Zeigt alles zur Fehleranalyse an.

</td></tr>
<tr><td valign="top"><b>Ocr_variator</b>:</td><td>Versucht Fehler zu beheben, die durch das Einscannen von Texten entstehen
können.

</td></tr>
</table>
<p>
Weiterhin kann für den Einstieg nicht schaden, einen Blick in die
Konfigurationen rubyling.xml und ocr.xml zu werfen.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>